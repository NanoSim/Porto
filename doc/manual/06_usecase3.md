# Use Case 3. Coupling of parScale to Ansys FLUENT

This will be updated at a later time.

Demonstrate that data from the particle scale model **parScale** can be used in the generation of an **Ansys FLUENT** UDF using **Porto**. 


## Walkthrough

This walkthrough is a continuation from the previous Use Case and assumes that it has already been run, followed by running parScale. ParScale will in this case have produced the following output:

* An `effectivenessFactor.json` file containing a description of the functional form of the effectiveness factor.
* An `effectiveReactionparameters.json` file containing a description of the functional form of the effective reaction parameters.

By "functional form" we here mean that each of these properties are described by the choice of a function and arguments to this function. For example, one simple functional form with one argument could be a _constant effectiveness factor_, written in C code as

    double constantEffectivenessFactor(double c) {
       return c;
    }

Since the choice of functional form that best represents the different parameters (effectiveness factor and effective reaction parameters) are expressed by parScale, we can use this information to generate an Ansys FLUENT UDF which takes this into account. Generation of the UDF is similar to the UDF generation done in Use Case 1.

**TODO: We actually do not have reading of the .json files to Porto yet, so the following section does not actually run**

In order to store the 

    $ ./effectivenessFactor-to-entity.json a6a71841-139a-4310-a9e6-ef7a6f161a6f effectivenessFactor.json

**TODO: Complete this**

* Simulate reaction and record (i) average particle temperature, (ii) current total consumption rate of gas-phase species A, and (iii) conversion of the solid
* Postprocessing step 1: calculate and plot (i) consumption rate of A versus conversion X for different C_A. Repeat exercise for different temperature to determine k, m, and n.
* Calculate the fitting values for k, n and m in the rate expression
* The effectiveness factor (parameters k_fit and m, as well as the functional form) is written to a .json file from an Octave script that processes the ParScale output
* then read into Porto using an External Plugin

(Alternative approach, if feasible: Ef is written directly from ParScale using Porto. We will investigate whether this is a feasible approach within the time available.)

* Porto stores Ef in an entity
* An UDF for Fluent is generated using the UDF generation in Porto



### `effectivenessFactor.json`

The `.json` file generated by parScale has the following example structure:

    {
      "name": "effectivenessFactor",
      "nparameters": 1,
      "functionalForm": "constant",
      "parameters": [
        0.1234
      ],
      "argumentCount": 0
    }

### `effectiveReactionparameters.json`

The `.json` file generated by parScale has the following example structure:

    {
      "name": "effectiveReactionparameters",
      "nparameters": 2,
      "multiplyByParticleVolumeFraction": true,
      "functionalForm": "OneMinusConversionTimesConcentration",
      "parameters": [
        0.6667,
        1
      ],
      "argumentCount": 3
    }

## Details

### `generate-effectiveness-udf.js`

      #!/usr/bin/env softshell
      var entity = require('porto.entity');
      porto.EffectivenessFactor = entity.using('effectivenessfactor', 'eu.nanosim.parscale', '0.2');
      porto.EffectiveReactionparameters = entity.using('effectivereactionparameters', 'eu.nanosim.parscale', '0.2');

      __main__ = function (args) {
         try {
            // Check that the user provides sufficient arguments to the program
            if (args.length < 2) {
                  print("Usage " + args[0] + " <uuid>");
                  return;
            }

            var uuid = args[1];

            // Attempt to talk to the local mongodb
            var storage = new porto.Storage("mongo2", "mongodb://localhost", "db=porto;coll=demo");

            // Load the collection given by the uuid on the command line, then retrieve all
            // reaction entities in this collection
            collection = new porto.Collection(uuid);
            storage.load(collection);

            var effectivenessfactorID = collection.findRelations("Effectivenessfactor", "id");
            var effectivereactionparametersID = collection.findRelations("Effectivereactionparameters", "id");

            console.raw("Collection uuid: " + collection.id() + "\n");
            console.raw("effectivenessfactorID: " + effectivenessfactorID + "\n");
            console.raw("effectivereactionparametersID: " + effectivereactionparametersID + "\n");

            var ef = new porto.EffectivenessFactor(effectivenessfactorID);
            ef.read(storage);

            var erp = new porto.EffectiveReactionparameters(effectivereactionparametersID);
            erp.read(storage);
            
            // TODO: Map the arguments to variable names here


            // Pass the aggregated information from the entity to the code generator (soft.mvc). The
            // variables here (elements, species, reactions) can be found in the template specified
            // below. This will substitute the template entrires such as @{elements} with the contents
            // specified below.
            var controller = require('soft.mvc').create({
                  model: {
                     effectivenessFactor: {
                        functionalForm : ef.functionalForm,
                        parameters : ef.parameters.join(", ") // TODO: Also concat the arguments
                     }, 
                     effectiveReactionparameters: {
                        functionalForm : erp.functionalForm,
                        parameters : erp.parameters.join(", "), // TODO: Also concat the arguments
                        multiplyByParticleVolumeFraction : (erp.multiplyByParticleVolumeFraction == 1 ? true : false)
                     }
                  },
                  view: "./template/udf.cjs"
            });

            // Output the generated code directly to the console.
            // TODO: Add capability to write it to a named file instead.
            console.raw(controller());

         } catch (err) {
            // Any error caught during execution is logged to the console.
            console.raw("ERROR: Failed generating code.\nReason: " + err + "\n");
         }

      };






### `udf.cjs`

    #include "udf.h"

    real effectiveness_factor_functional_form_constant(real p1) {
      return 0.0; // TODO Something here
    }

    real effectiveness_factor_functional_form_somethingelse(real p1, real p2, real p3) {
      return 0.0; // TODO Something here
    }

    real effective_reaction_parameters_functional_form_constant(real p1) {
      return 0.0; // TODO Something here
    }

    real effective_reaction_parameters_functional_form_somethingelse(real p1, real p2, real p3) {
      return 0.0; // TODO Something here
    }

    // TODO The name defined here should probably be something else
    DEFINE_HET_RXN_RATE(NiO_CH4,c,t,r,mw,yi,rr,rr_t)
    {

         // NOTE: There are some issue with storing and communicating bools across language barriers, so we use an integer for now: 
         if (@{soft.model.effectiveReactionparameters.multiplyByParticleVolumeFraction} == 1) {
           // TODO Something here
       }

       real x = effectiveness_factor_functional_form_@{soft.model.effectivenessFactor.functionalForm}(
          @{soft.model.effectivenessFactor.parameters}
          );

       real Rrate, k, S0, X_CH4, MW_CH4, vol_frac_solid;
       Thread *gas_thread = THREAD_SUB_THREAD(t,0);
       Thread *solid_thread = THREAD_SUB_THREAD(t,1);

       vol_frac_solid = C_VOF(c,solid_thread);
       X_CH4 = yi[0][2];
       MW_CH4 = mw[0][2];

       S0 = @{soft.model.S0Eq}; 
       k = @{soft.model.kEq};
       Rrate = @{soft.model.RrateEq};  

       if (X_CH4 < min_cutoff) Rrate = 0;     

       if (vol_frac_solid < min_cutoff) Rrate = 0;		  

       *rr = Rrate / 1000.0;
    }
