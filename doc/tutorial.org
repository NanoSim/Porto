#+TITLE: Soft tutorial
#+AUTHOR: Thomas Hagelien
#+LANGUAGE: en

* A brief introduction to softshell

Softshell is a scripting tool for performing various tasks related to
the NanoSim platform development, data and process management and
simulator connectivity. The scripting language is based on ECMAScript,
better known as JavaScript (although the language is not related to
Java, and has a completely different semantics). For more background
on the JavaScript language, please consult your nearest google search
engine.

In addition to being ECMA-262 compatible, the Portoshell also
supports custom extensions. These come in different flavors:

 -  Standard build-in utility extensions (JavaScript)
 -  External modules (JavaScript)
 -  Plug-in support (written or wrapped in C++)

** Standard built-in utility extensions
At the current moment of writing, the Porto standard build-in modules are
  - Process Module
  - EventLoop Module
  - UDP Socket Module
  - Console Module
  - File System Module
  - File System Watcher Module
  - Httpd Module 

These modules are considered core features and provide functionality
to increase productivity.

** External modules 
The external JavaScript modules are extensions that are easy to
manipulate and reload at runtime. They are containers of data and
functions that can be loaded through the build-in function:

#+BEGIN_SRC js
  require (modulename)
#+END_SRC

The modulename can either be a javascript file, or a modulename including namespace

#+BEGIN_SRC js
  require ('porto.mvc');  // fetching a registered module
#+END_SRC

#+BEGIN_SRC js
  require ('/path/to/file.js'); // fetching a module scriptfile
#+END_SRC

The difference between a module and a regular script file is that a
module is captured within a javascript closure, accessing an object
named 'exports'. Only variables and functions that are set as
properties to exports will be available from the callee. This avoids
naming pollution and provides nice module APIs.

#+SOURCE: stuff
#+BEGIN_SRC js
  (function (mymodule){
    mymodule.hello = function (){ 
      console.log ("Hello Porto Modules!");
    }
  })(exports);
#+END_SRC

#+SOURCE: dd
#+BEGIN_SRC js
  require('mymodule.js').hello();
  // => Hello Porto Modules!
#+END_SRC

At the time of writing we currently have the following 'standard'
external modules:

| Module                | Description                                                |
|-----------------------+------------------------------------------------------------|
| porto.entity          | /Simplifies working with entities/                         |
| porto.collection      | /Defines the API for Collections/                          |
| porto.macro           | /Macro expansion module/                                   |
| porto.mvc             | /Model View Controller code generator framework/           |
| porto.storage         | /Storage context class with factory/                       |
| porto.storage.json    | /Experimental ultralight JSON storage extension/           |
| porto.storage.mongo   | /MongoDB wrapper utility/                                  |
| porto.utils.metastore | /Utility for storing metadata in the metadata database/    |
| porto.factory.entity  | /Factory for dynamic runtime generation of entity classes/ |
|-----------------------+------------------------------------------------------------|

 
** Plug-in support (C++)
The last method of extending Portoshell is through pre-compiled
plugins that are loaded at startup. These plugins can provide access
to C/C++/++ libraries through C++/Scripting interfaces. Details of how
this is performed are beyond the scope of this tutorial. There is
currently only one plug-in available in Porto, namely the
/MongoDB-plugin/ which gives a low-level access to the mongodb
C-driver API.
* Creating your first script

In this section you will be introduced to scripting in portoshell. We'll start with the clichÃ© hello-world:

#+NAME: Hello-World
#+BEGIN_SRC js 
__main__ = function (args)
{
    print ("Hello, World");
}
#+END_SRC

#+RESULTS: Hello-World

To execute this script from command-line, save this script to a file /hello.js/ and call

#+BEGIN_SRC sh
portoshell hello.js
#+END_SRC

The key idea here is that the script file will need to have defined an entry body

#+BEGIN_SRC js 
__main__ = function (args)
#+END_SRC

that will be called from the script engine. 

If no arguments are given to portoshell, you will start the interactive
REPL (Read-evaluate-print-loop). This is a useful environment for
experimenting and interactive development.

#+BEGIN_EXAMPLE
$ portoshell
PortoShell 0.1.32
Source license: LGPLv3

For help, type :help

> print ("Hello");
Hello
undefined
> 

#+END_EXAMPLE

Notice the text /undefined/ that gets printed after the output is
written. This is the return value of the expression evaluation. If the
expression doesn't return av valid value, the value /undefined/ gets
written.


* Working with metadata

Now you have the fundamentals covered to get started working with data
and metadata. Meta-data is a high-level description of data that
identifies how data from any source can be interpreted. Meta-data
should be uniquely identified with a name and version
number. Furthermore, the metadata should be defined as lists of
properties that identifies names, type, units, dimensions etc for each
element.

** Example: Unit metadata
Let's start with a simple example: Define meta-data for the entity
/unit/. The unit-entity should contain the following fields:

  - abbreviation
  - code
  - conversionMultiplier
  - conversionOffset
  - quantityKind
  - symbol
  - unit
  
This follows the structure defined by [[http://qudt.org/][QUDT]]

The formal meta-entity is specified in JSON like this:

#+BEGIN_SRC js
{
    "name": "unit",
    "version": "1.0-SNAPSHOT-1",
    "description": "Unit definitions",
    "properties": [
       {
         "name": "abbreviation",
         "type": "string"
       },
       {
         "name": "code",
         "type": "string"
       },
       {
         "name": "conversionMultiplier",
         "type": "double"
       },
       {
         "name": "conversionOffset",
         "type": "double"
       },
       {
         "name": "quantityKind",
         "type": "string"
       },
       {
         "name": "symbol",
         "type": "string"
       },
       {
         "name": "unit",
         "type": "string"
       }
    ]
}
#+END_SRC 

Save this contents in a file named 'unit.json'. To insert this file
into the meta-database, perform the following operation from a shell

#+BEGIN_SRC sh
$ register-entity.sh unit.json

2014/06/14 15:00:40.0110: [18265]: INFO: cluster: Client
initialized in direct mode.
{"name":"unit","version":"1.0-SNAPSHOT-1","description":"Unit     
definitions","properties":[{"name":"abbreviation","type":"string"},
{"name":"code","type":"string"},{"name":"conversionMultiplier",
"type":"double"},{"name":"conversionOffset","type":"double"},{"name":
"quantityKind","type":"string"},{"name":"symbol","type":"string"},
{"name":"unit","type":"string"}]}
#+END_SRC

The /register-entity.sh/ script is a utility that inserts a json-file
into MongoDB. If we take a look at the file /register-entity.sh/, you
will find that this is not a regular shell-script at all, but a script
that actually gets run by portoshell

#+BEGIN_SRC js
#!/usr/bin/env portoshell

/*
 * register-entity.sh
 * A utility to commit meta-data into the metadata-database
 */

__main__ = function (args)
{
    if (args.length == 0) {
           console.error("fatal error: no input files");
           return undefined;
       }
    var metaStorage = require ('porto.utils.metastore').connect(
        {
            uri: 'mongodb://localhost',
            database: 'meta',
            collection: 'entities'
        });
    args.forEach(function(file){
        fs.readFile(file, function(err, data) {
            if (err) {
                print ("error:", err);
                return;
            }
            if (!metaStorage.store (data)) {
                print ("Failed to write data");
            }
        });
    });
}

#+END_SRC

If you look closely, you will see that our meta-database is (here)
hard-coded to be the database: '/meta/', collection: '/entities/' in a
mongodb server running on /localhost/. Don't worry if you don't
understand the rest of the script.

The file [[https://github.com/NanoSim/Porto/blob/master/portotools/examples/portoshell/registerentity/units.json][units.json]] is a collection of all the documented units
available from [[qudt.org][qudt.org]]. Our goal now is to create an instance of the
entity /Unit/, fill it with the contents of the existing data, and
store the data as an entity in MongoDB.

** Creating instances of entities

Creating an entity of type unit can now be performed runtime in the scripting environment:

#+BEGIN_SRC js
var entity = require('porto.entity').db(driverInfo);   
Unit       = entity.using('unit', '1.0-SNAPSHOT-1');
#+END_SRC

Notice that we never implement the object /Unit/. This is generated
for us, based on the metadata that we just stored. The return value
from /entity.using/ is actually the /Unit.protocol.constructor/
reference.  The variable '/u/' is now holding a new instance of the
class '/Unit/'. It is also possible to call createEntity with a
callback function that will capture errors and the class definition
(the function that creates the class passed as text).


** Storing data to the database

The storage where we want to store the entity values could be a number
of different locations. The storage-module contains a factory pattern
that allows us to specify the name of the driver we want to use,
together with other info. We are not bound to a single driver such as
MongoDB at this point. Any supported driver can be loaded runtime and
used for storage and data retrieval.

#+BEGIN_SRC js
    /* connectivity information */
    var driverInfo = {
	driver:     'mongodb',
	database:   'porto',
	collection: 'units'
    };
#+END_SRC

In this case we want to store our data in a database called '/porto/',
in a collection we call /units/.  Let's fill an entity with some
data and store the contents to the database:

#+BEGIN_SRC js
    var unit = new Unit();
    u.set({
        abbreviation: "Gy/s",
        code: "0780",
        conversionMultiplier: "1.0e0",
        conversionOffset: "0.0",
        quantityKind: "quantity:AbsorbedDoseRate",
        symbol: "Gy/s",
        unit: "GrayPerSecond"
    });
#+END_SRC

The /Unit/ object is generated with a set of getter and setter
functions. We could equally well have written something like this:

#+BEGIN_SRC js
...
u.setAbbrevation ("Gy/s");
u.setCode ("0780");

...
#+END_SRC

To finalize the process, we can now store the data as a value in our database:

#+BEGIN_SRC js
u.store();
#+END_SRC

The complete example should now look like this:

#+BEGIN_SRC js
    /* connectivity information */
    var driverInfo = {
	driver:     'mongodb',
	database:   'porto',
	collection: 'units'
    };

    /* Entity creator */
    var entity = require('porto.entity').db(driverInfo);   
    Unit       = entity.using('unit', '1.0-SNAPSHOT-1');

    var u = new Unit();

    u.set({
        abbreviation: "Gy/s",
        code: "0780",
        conversionMultiplier: "1.0e0",
        conversionOffset: "0.0",
        quantityKind: "quantity:AbsorbedDoseRate",
        symbol: "Gy/s",
        unit: "GrayPerSecond"
    });

    u.store();
    print (u.id);
#+END_SRC 

In this example we've seen how an entity can be generated runtime for
us, based on meta-data. In other languages, the code generation might
have to be performed compile-time, and included in the code-base. This
is, however, semantically equal to what we've shown here. The key
concept is that '/meta-data/' defines the schema, the storage driver
is completely separated from the implementation of the Entity
instance, and the correct coupling can be performed runtime, giving
extreme flexibility.

The last command in the example prints the unique identifier of the
entity. This value as an [[http://en.wikipedia.org/wiki/Universally_unique_identifier][universally unique identifier]] and needs to be
communicated between processes that work with the same data.

** Reading data back from a database

Our storage device have defined both read and write operations, so we
can reuse our storage from the previous example. To read back data
(from a different application) we can simply instantiate our entity
with the UUID generated be the instance.

#+BEGIN_SRC js
    /* let's pretend the UUID we got was
    8dd10147-d0b9-48ee-ae9b-2ef41d56add9 */
   
    var id = '8dd10147-d0b9-48ee-ae9b-2ef41d56add9';
    var entity = require('porto.entity').db(driverInfo);   
    Unit       = entity.using('unit', '1.0-SNAPSHOT-1');

    var u = new Unit(id);    
#+END_SRC 

Working Porto doesn't really require the developer to deal with a lot
of different APIs. Hiding the boilerplate code in configuration files
leaves the developers to simply instantiate a class/module/object and
start working with the data in a language native way.

There is another important thing to consider as well. In our client
code we have said (made a contract) that we want to use the entity
/unit:1.0-SNAPHOT-1/. However, we don't say anything about the source
type. This is one of the more sophisticated features of the Porto
design. If the data source that stored the contents of the entity with
the id= '/8dd10147-d0b9-48ee-ae9b-2ef41d56add9/', was of a different
kind, the framework would notice that the client entity and source
entity was different, and it would search for an explicit
 /translator/. The translators are simply code that accepts a given
entity type and returns a different one. The client code will never
have to include its own version control to accommodate for changes in
file formats etc. We can simply just state /what/ entity we want to
use, and that's the end of that. 

** Introducing Collections

Collections are simply a formal specification of an entity that
contains information about other entities and their relations. One of
the key design principles of the Proto data centric design is the
separation of data (entities) and structures (relations). The
Collection constructor is defined in the external module
/porto.collection/.

#+BEGIN_SRC js
    Collection = require('porto.collection').db(driverInfo);
    var myCollection = new Collection();
#+END_SRC

The Collection class has the following API

| Function                      | Description                                              |
|-------------------------------+----------------------------------------------------------|
| setName(name)                 | Set the collection name                                  |
| name()                        | Get the name of the collection                           |
| setVersion(version)           | Set the version of the collection                        |
| version()                     | Get the version of the collection                        |
| count()                       | Return the number of registered entities                 |
| instances()                   | Return the label of each entity instance                 |
| findInstance(label)           | Return the entity object with the given label            |
| registerRelation(from,to,rel) | Creates a relation between two entities                  |
| registerEntity(entity,label)  | Registeres an entity with a given (locally unique) label |


This will create an empty collection.

Let's create a script that does the following
   1. Read the complete file of units 
   2. Create a collection that should contain the complete set of unit entities
   3. Create new entities for each unit and store the value
   4. Register the entity in the collection
   5. Store the collection and report the UUID:

#+BEGIN_SRC js
var unitsJSON = fs.readFile('units.json', function(err, data){
    if (err) throw(err);

    /* connectivity information */
    var driverInfo = {
	driver:     'mongodb',
	database:   'porto',
	collection: 'units'
    };

    /* Entity and Collection creators */
    Collection = require('porto.collection').db(driverInfo);
    var entity = require('porto.entity').db(driverInfo);   
    Unit       = entity.using('unit', '1.0-SNAPSHOT-1');

    /* Parse the external file into a javascript object */
    var obj = JSON.parse(data);

    /* Instantiate a new Collection class */
    var unitLibrary = new Collection();
    unitLibrary.setName('UnitCollection');
    unitLibrary.setVersion('1.0');
    
    /* Iterate through all the units and make a call the callback function */
    obj.units != undefined && obj.units.forEach (function(unitObj) {
	/* Create a new Entity for each element in the list */
	var unitEntity = new Unit();
	unitEntity.set(unitObj);
	unitEntity.store();

	/* Register the entity in the Collection class*/
	unitLibrary.registerEntity (unitEntity, 'entity'+unitEntity.code);
    });

    /* Store the Collection */
    unitLibrary.store();

    /* Display the id of the collection */
    console.log (unitLibrary.id);
});

#+END_SRC

** Introducing the Porto MVC code generator

The code generator is implemented in the external module
'porto.mvc'. This module contains only one function (/create()/),
which takes as the argument a model (object) and a view (template
file), and returns a new function that will expand the
javascript-markup contents of the view template and return a
string. The generate method takes a '/bag/' object as an optional
argument. Every property connected to bag will be available in the
view template js-code. In addition to /bag/, the porto.model - defined
in the /create(obj)/ function call, will be available.

Let's create an example where we instantiate our unit library that we
just stored. Then we pass the collection contents to the view template
which expands the contents from the MongoDB and into a HTML-document,
that will present the unit library as tables.

#+BEGIN_SRC js
    var driverInfo = {
        driver: 'mongodb',
        database: 'porto',
        collection: 'units'
    };

    Collection = require('soft.collection').db(driverInfo);

    /* Instantiate our unitLibrary collection */
    var collectionID = '79fe6b02-7b9e-4339-b238-983333b37552';
    var unitLibrary  = new Collection(collectionID);

    /* Create a generate function*/
    var generate = require('soft.mvc').create({
        model: unitLibrary.get(),
        view: 'webtemplate.jshtml'
    });

    /* Store the result to an output file */
    fs.writeFile ('output.html', generate(driverInfo), function(err){
        if (err) throw (err);
    });

#+END_SRC 

We will also need our template. It looks a bit ugly, but hey - it is what it is:

#+BEGIN_SRC html
@{
  var entity = require('soft.entity').db(porto.bag);
  Unit = entity.using('unit', '1.0-SNAPSHOT-1');
  createTable = function(unit){
    return "<table style=\"width:300px\"><tr><th colspan=\"2\">unit:" +
    unit.unit + "</th></tr><tr><th>Property</th><th>Value</th></tr><tr><td>abbreviation</td><td>"+
    unit.abbreviation+"</td></tr><tr><td>code</td><td>"+
    unit.code+"</td></tr><tr><td>conversionMultiplier</td><td>"+
    unit.conversionMultiplier+"</td></tr><tr><td>conversion offset</td><td>"+
    unit.conversionOffset + "</td></tr><tr><td>quantityKind</td><td>"+
    unit.quantityKind+"</td></tr><tr><td>symbol</td><td>"+ unit.symbol+"</td></tr></table>"
  }
}
<html>
  <head>Generated at @{new Date().toString()}
  <link rel="stylesheet" type="text/css" href="http://www.qudt.org/qudt/owl/1.0.0/styles/nexiom.css"/>
  </head>
  <body>
    <h1>Generated from @{porto.model.__name__} version @{porto.model.__version__}</h1>
    The original data is available from <a href="http://www.qudt.org">qudt</a>
    @{porto.model.entities.map(function(obj){
      var unit = new Unit(obj.uid);
      return createTable(unit);
    }).join("<br/>");}
  </body>
</html>

#+END_SRC

Run the script and enjoy the results.

** Summary

In this chapter we've touched upon some key features of Porto:
  - Defining meta-data schemas and storing them in a database
  - Creating instances of entities that are bound to the meta-data schema
  - Creating collections of entities
  - Storing and retrieving data using the generic storage interface
  - Generating code based on data contents stored in the MongoDB database

* Working with OpenFOAM

In this chapter we show how Porto can be used to generate inputs for
OpenFOAM. This is a partial example and should be extended to a
complete simulation environment run from within Porto.

** Defining meta-data
As always, we start with the data modelling and implementing our
meta-data schemas. The simplest OpenFOAM entity to define is proably
the OpenFOAM control dictionary /controlDict/

We could be more explicit in the definition and give the properties
units etc. It would also be better to use enumerators instead of
string-types for some of the properties.

#+BEGIN_SRC js
{
    "name"        : "controlDict",
    "version"     : "0.1",
    "description" : "Time and data input/output control",
    "properties"  : [
	{
	    "name": "application",
	    "type": "string"
	},
	{
	    "name": "startFrom",
	    "type": "string"
	},
	{
	    "name": "startTime",
	    "type": "double"
	},
	{
	    "name": "stopAt",
	    "type": "string"
	},
	{
	    "name": "endTime",
            "type": "double"
	},
	{
	    "name": "deltaT",
	    "type": "double"
	},
	{
	    "name": "writeControl",
	    "type": "string"
	},
	{
	    "name": "writeInterval",
	    "type": "double"
	},
	{
	    "name": "purgeWrite",
	    "type": "integer"
	},
	{
	    "name": "writeFormat",
	    "type": "string"
	},
	{
	    "name": "writePrecision",
	    "type": "integer"
	},
	{
	    "name": "writeCompression",
	    "type": "string"
	},
	{
	    "name": "timeFormat",
	    "type": "string"
	},
	{
	    "name": "timePrecision",
	    "type": "integer"
	},
	{
	    "name": "runTimeModifiable",
	    "type": "string"
	},
	{
	    "name": "adjustTimeStep",
	    "type": "string"
	}
    ]
}

#+END_SRC

Let's save this file under the name '/controldict.json/'

** Storing the meta-data

The next step is to store this data to the meta-data database. We can
do this by using the utility /register-entity.sh/.

#+BEGIN_SRC sh
    $ register-entity.sh controldict.json 

    2014/06/20 15:08:27.0408: [16726]: INFO: cluster: Client initialized
    in direct mode.
    {"name":"controlDict","version":"0.1","description":"Time and data
    input/output
    control","properties":[{"name":"application","type":"string"},
    {"name":"startFrom","type":"string"},{"name":"startTime","type":"double"},
    {"name":"stopAt","type":"string"},{"name":"endTime","type":"double"},{"name":
    "deltaT","type":"double"},{"name":"writeControl","type":"string"},{"name":
    "writeInterval","type":"double"},{"name":"purgeWrite","type":"integer"},
    {"name":"writeFormat","type":"string"},{"name":"writePrecision","type":"integer"},
    {"name":"writeCompression","type":"string"},{"name":"timeFormat","type":"string"},
    {"name":"timePrecision","type":"integer"},{"name":"runTimeModifiable","type":"string"},
    {"name":"adjustTimeStep","type":"string"}]}

#+END_SRC


** Instantiate an ControlDict entity

Now that we have the meta-data available, we can instantiate the
ControlDict object and give it some data:

#+BEGIN_SRC js
  var entity = require('soft.entity').db({
    driver:     'mongodb',
    database:   'porto',
    collection: 'openfoam'
  });

  ControlDict = entity.using('controlDict', '0.1');

  /* Create an instance and give it some data*/
  var nozzleControlDict = new ControlDict();
  nozzleControlDict.set({
    application       : 'mdFoam',
    startFrom         : 'startTime',
    startTime         : 0,
    stopAt            : 'endTime',
    endTime           : 2e-13,
    deltaT            : 1e-15,
    writeControl      : 'runTime',
    writeInterval     : 5e-14,
    purgeWrite        : 0,    
    writeFormat       : 'ascii',
    writePrecision    : 12,
    writeCompression  : 'off',
    timeFormat        : 'general',
    timePrecision     : '6',
    runTimeModifiable : 'true',    
    adjustTimeStep    : 'no'
  });

  /* Store the entity in the database */
  nozzleControlDict.store();

  /* Display the UUID for further use */
  print (nozzleControlDict.id);

#+END_SRC

** Create the template view for the generated file

The next step is to make a template view for the file to be generated.

#+BEGIN_SRC C
/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  2.1.1                                 |
|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |
|    \\/     M anipulation  |                                                 |
|-----------------------------------------------------------------------------|
    Generated by Porto @{new Date().toString()}
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      controlDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

application     @{porto.model.application};

startFrom       @{porto.model.startFrom};

startTime       @{porto.model.startTime};

stopAt          @{porto.model.stopAt};

endTime         @{porto.model.endTime};

deltaT          @{porto.model.deltaT};

writeControl    @{porto.model.writeControl};

writeInterval   @{porto.model.writeInterval};

purgeWrite      @{porto.model.purgeWrite};

writeFormat     @{porto.model.writeFormat};

writePrecision  @{porto.model.writePrecision};

writeCompression @{porto.model.writeCompression};

timeFormat      @{porto.model.timeFormat};

timePrecision   @{porto.model.timePrecision};

runTimeModifiable @{porto.model.runTimeModifiable};

adjustTimeStep  @{porto.model.adjustTimeStep};

// ************************************************************************* //

#+END_SRC 

** Generate a controlDict file

The last step is to generate the code that makes the controlDict.

#+BEGIN_SRC js

  var entity = require('soft.entity').db({
    driver:     'mongodb',
    database:   'porto',
    collection: 'openfoam'});

  ControlDict = entity.using('controlDict', '0.1');

  var controlDict = new ControlDict('e12686f9-b677-49dc-ad9d-07944f9b053e');
  var generate = require('soft.mvc').create({
    model: controlDict.get(),
    view : 'controlDict.foamjs'});

  fs.writeFile('controlDict', generate(), function(err){
    if (err) throw (err);
  });

#+END_SRC

Running this script will create a completely heatly OpenFOAM
controlDict dictionary file.

* Developing C++ w/code generation

Working in a scripting environment is effective and powerful, but when
it comes to production code we're often more interested in working
with compiled languages such as C++, Fortran and Java. By bringing in
the same elements from Porto scripting into these languages we unleash
the true power of data-centric development. Being able to instantiate,
store and retrieve entities directly in the numerical simulators, we
reduce the unnecessary boilerplate code and IO infrastructure. Ideally
our models should be developed to do just one thing, and do it well -
compute!

** Background and design
Our meta-data for defining entities can be used with the Porto.MVC
framework to generate a code representation of the entity. In this
tutorial we'll focus on C++. Let's start with our unit-entity again
and see if we can come up a simple, but reasonable design for a C++
structure that can be used.

#+BEGIN_SRC C++
class Unit : public IEntity
{
public:
    Unit();
    virtual ~Unit();

    std::string abbreviation;
    std::string code;
    double conversionMultiplier;
    double conversionOffset;
    std::string quantityKind;
    std::string symbol;
    std::string unit;
};
#+END_SRC

Ok, so we're violating the first principle of OO-programming: "Data
should be hidden". Feel free to experiment with an implementation with
setters and getters. What you gain is zero - and setters/getters are
OO-anti patterns. However, this is the data-centric approach, and the
key strategy is to put the data up front.

In the back-end of our C++ framework we want to instantiate a Storage
class that can take as a parameter a /driver/ type, together with some
optional arguments. To do this in a generic way I propose to implement
the framework using the Named Parameter Idiom. This way we can write
code like this:

#+BEGIN_SRC
   Storage storage = connect("mongodb")
      .addOption("database", "porto")
      .addOption("collection", "mystorage");

#+END_SRC

To illustrate how generic this approach is, we can use the same interface to
instantiate a storage based on a mysql-database:

#+BEGIN_SRC
   Storage storage = connect("mysql")
      .addOption("user",    "dbuser")
      .addOption("password, "secret")
      .addOption("hostName","localhost")
      .addOption("port",    3306);
   ...
#+END_SRC

Now we have our storage. But we do not want every instance of the
entities we include in our system to be registered with a storage
class. The main idea is that the entities themselves are
/IO-agnostic/. To be able to do this, we introduce the concept of a
data /Transactor/. The /Transactor/ is created given a reference to
the storage. Internally it maintains a list of registered entities. An
entity can belong to none or many different transactors at the same
time. This enable us to define things such as loggers, where some data
points should be stored frequently to a local text file, while the
entire state of the software might be stored only at the end of the
simulation.

#+BEGIN_SRC
class Transactor
{
   Transactor(){}
   Transactor(Storage const &storage);
   
public:
   ~Transactor();
   static Transactor create(Storage const &storage);
   void add(IEntity *entity);
   void store();
   void fetch();

private:
   class Private;
   Private *d;
};

#+END_SRC

So our program might now look like this


#+BEGIN_SRC
#include <Porto>
#include "unit.h"
int main(int, char**)
{
   Storage storage = StorageCreator::connect("mongodb")
      .addOption("database", "porto")
      .addOption("collection", "mystorage");

   auto transactor = Transactor::create(storage);

   Unit unit; // Instantiate our unit-entity
   transactor.add(&unit); // append unit to a transactor list
 
   ...

#+END_SRC

Let's fill in some data:

#+BEGIN_SRC C++
   Unit unit;

   unit.abbreviation         = "Gy/s";
   unit.code                 = "0780";
   unit.conversionMultiplier = 1.0e0;
   unit.conversionOffset     = 0.0;
   unit.quantityKind         = "quantity:AbsorbedDoseRate";
   unit.symbol               = "Gy/s";
   unit.unit                 = "GrayPerSecond";

#+END_SRC


Our entity is not quite finished yet. We need to include some code
that actually feeds the storage data model with the contents of the
entity. Since we do not want to expose this to the entity class we can
implement a helper class that knows the structure/schema of our entity

#+BEGIN_SRC C++
class UnitStore
{
public:
   static bool set(Unit const *e, StorageObject &obj);
   static bool get(Unit *e, StorageObject const &obj);
};

#+END_SRC

A first attempt on an implementation of this could look like this:

#+BEGIN_SRC C++
bool UnitStore :: set(const Unit *e, StorageObject &obj)
{
  obj.insert("abbreviation", StorageValue(e->abbreviation));
  obj.insert("code", StorageValue(e->code));
  obj.insert("conversionMultiplier", StorageValue(e->conversionMultiplier));
  obj.insert("conversionOffset", StorageValue(e->conversionOffset));
  obj.insert("quantityKind", StorageValue(e->quantityKind));
  obj.insert("symbol", StorageValue(e->symbol));
  obj.insert("unit", StorageValue(e->unit));		    
  return true;
}

bool UnitStore :: get(Unit *e, StorageObject const &obj)
{
  e->abbreviation = obj.find("abbreviation").toString();
  e->code = obj.find("code").toString();
  e->conversionMultiplier = obj.find("conversionMultiplier").toDouble();
  e->conversionOffset = obj.find("conversionOffset").toDouble();
  e->quantityKind = obj.find("quantityKind").toString();
  e->symbol = obj.find("symbol").toString();
  e->unit = obj.find("unit").toString();
  return true;
}

#+END_SRC

To finish up the code, we should be able to just call /store/ from the transactor:

#+BEGIN_SRC C++
   ...
   transactor.store();
   return EXIT_SUCCESS;
}
#+END_SRC

The storage/transactor infrastructure is/will be a part of the
portobase library. This chapter will focus on how we use registered
entities in our simulation code with very little effort (i.e. avoiding
to implement the classes manually etc)

** Generic Code Generation script

We're able to implement shell-application using Porto scripting, so
let's do that to implement a generic Porto-MVC code generator utility.

   1. Read a meta-data schema from file
   2. Create a porto.mvc generator based on the meta-data object and a view-file
   3. Send the code back to stdout



#+BEGIN_SRC js
#!/usr/bin/env portoshell

__main__ = function (args){    
    var name = args[1];
    var viewfile = args[2];
    fs.readFile(name + ".json", function(err, data){
	if (err) throw (err);
        generate = require('porto.mvc').create({
	    model: JSON.parse(data),
	    view: viewfile
	});
	console.log(generate({filename: name}));
    });
};
#+END_SRC

This will work, but if our input schema is faulted or the
view-template contains errors, we will not be easily able to find out
where it went wrong.

#+BEGIN_SRC js
#!/usr/bin/env portoshell

__main__ = function (args){    
    var name = args[1];
    var viewfile = args[2];
    fs.readFile(name + ".json", function(err, data){
	if (err) throw (err);
	try {
	    generate = require('porto.mvc').create({
		model: JSON.parse(data),
		view: viewfile
	    });
	} catch (e) {
	    console.error(e);
	    return;
	}
	try {
	    console.log(generate({filename: name}));
	} catch (e) {
	    console.error(e);
	}
    });
};

#+END_SRC

This is a little better. At least we will now get some hints of what
went wrong. If you want to go even further you can even include the
entity-schema validator.
  
** Create view-templates for C++ source and header files

If we assume for now that our entities can only have scalar values,
and we're limited to numbers and strings, we can define a template
that generates our header file (including the Store-helper)

#+BEGIN_SRC js
@{
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};
function typeToCppType(type) {
  var typemap = {
    "integer": "int",
    "int"    : "int",
    "double" : "double",
    "string" : "std::string",
    "boolean": "bool"
  };
  return typemap[type];
}
propertyList = porto.model.properties.map(function(prop){
  return typeToCppType(prop.type) + " " + prop.name + ";";
}).join("\n  ");
Classname = capitalize(porto.model.name);
undefined
}
/*
 * Generated by Porto @{new Date().toString()} 
 */

#ifndef @{porto.bag.filename.toUpperCase()}_H_DEF
#define @{porto.bag.filename.toUpperCase()}_H_DEF

#include "ientity.h"
#include <string>

class @Classname : public IEntity
{
public:
  @{Classname}();
  @{Classname}(@{Classname} const &other);
  virtual ~@{Classname}();

  static std::string _version();
  static std::string _name();
  @propertyList

protected:
   virtual bool store(StorageObject &storageObject);
   virtual bool restore(StorageObject const &storageObject);
};

class @{Classname}Store
{
public:
   static bool set(@{Classname} const *e, StorageObject &obj);
   static bool get(@{Classname} *e, StorageObject const &obj);
};

#endif

#+END_SRC

A full implementation view-template can be implemented like this:


#+BEGIN_SRC js
@{
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};
function typeToCppType(type) {
  var typemap = {
    "integer": "int",
    "int"    : "int",
    "double" : "double",
    "string" : "std::string",
    "boolean": "bool"
  };
  return typemap[type];
}

function typeToConvType(type) {
  var typemap = {
    "integer" : "toInt",
    "string"  : "toString",
    "double"  : "toDouble"
  };
  return typemap[type];
}

CopyConstructorParams = porto.model.properties.map(function(prop){
  return prop.name + " (other." + prop.name + ")"
}).join("\n  , ");


SetFuncBody = porto.model.properties.map(function(prop){
  return "obj.insert(\"" + prop.name + "\", StorageValue(e->"+ prop.name + "));";
}).join("\n  ");

GetFuncBody = porto.model.properties.map(function(prop){
  return "e->" + prop.name + " = obj.find(\""+ prop.name +"\")." + typeToConvType(prop.type) + "();"
}).join("\n  ");

Classname = capitalize(porto.model.name);
undefined
}
/*
 * A Generated by Porto @{new Date().toString()}
 */

#include "@{porto.bag.filename}.h"
#include "storageobject.h"
#include "storagevalue.h"
#include <iostream>
#include <string>

@Classname :: @{Classname}()
{}

@Classname :: @{Classname}(@{Classname} const &other)
  : @CopyConstructorParams
{}

@Classname :: ~@{Classname}()
{}

std::string @Classname :: _version()
{
  return std::string("@{porto.model.version}");
}

std::string @Classname :: _name()
{
  return std::string("@{porto.model.name}");
}

bool @Classname :: store(StorageObject &obj)
{
   return @{Classname}Store::set(this, obj);
}

bool @Classname :: restore(StorageObject const &obj)
{
   return @{Classname}Store::get(this, obj);
}

bool @{Classname}Store :: set(const @{Classname} *e, StorageObject &obj)
{
  obj.insert("__name__", StorageValue(e->_name()));
  obj.insert("__version__", StorageValue(e->_version()));
  @SetFuncBody		    
  return true;
}

bool @{Classname}Store :: get(@{Classname} *e, StorageObject const &obj)
{
  auto name = obj.find("__name__").toString();
  auto version = obj.find("__version__").toString();
  @GetFuncBody
  return true;
}

#+END_SRC

By running this through the code generator we should be able to produce the final result:

#+BEGIN_SRC sh
   $ ./genxx.js unit entity.hxxjs
#+END_SRC

Should produce this result:

#+BEGIN_SRC C++
/*
 * Generated by Porto Mon Jun 23 2014 21:25:47 GMT+0200 (CEST) 
 */

#ifndef UNIT_H_DEF
#define UNIT_H_DEF

#include "ientity.h"
#include <string>

class Unit : public IEntity
{
public:
  Unit();
  Unit(Unit const &other);
  virtual ~Unit();

  static std::string _version();
  static std::string _name();
  std::string abbreviation;
  std::string code;
  double conversionMultiplier;
  double conversionOffset;
  std::string quantityKind;
  std::string symbol;
  std::string unit;

protected:
   virtual bool store(StorageObject &storageObject);
   virtual bool restore(StorageObject const &storageObject);
};

class UnitStore
{
public:
   static bool set(Unit const *e, StorageObject &obj);
   static bool get(Unit *e, StorageObject const &obj);
};

#endif

#+END_SRC

Let's generate the implementation file as well

#+BEGIN_SRC sh
   $ ./genxx.js unit entity.cxxjs
#+END_SRC

Results in this
#+BEGIN_SRC C++
/*
 * A Generated by Porto Mon Jun 23 2014 21:27:28 GMT+0200 (CEST)
 */

#include "unit.h"
#include "storageobject.h"
#include "storagevalue.h"
#include <iostream>
#include <string>

Unit :: Unit()
{}

Unit :: Unit(Unit const &other)
  : abbreviation (other.abbreviation)
  , code (other.code)
  , conversionMultiplier (other.conversionMultiplier)
  , conversionOffset (other.conversionOffset)
  , quantityKind (other.quantityKind)
  , symbol (other.symbol)
  , unit (other.unit)
{}

Unit :: ~Unit()
{}

std::string Unit :: _version()
{
  return std::string("1.0-SNAPSHOT-1");
}

std::string Unit :: _name()
{
  return std::string("unit");
}

bool Unit :: store(StorageObject &obj)
{
   return UnitStore::set(this, obj);
}

bool Unit :: restore(StorageObject const &obj)
{
   return UnitStore::get(this, obj);
}

bool UnitStore :: set(const Unit *e, StorageObject &obj)
{
  obj.insert("__name__", StorageValue(e->_name()));
  obj.insert("__version__", StorageValue(e->_version()));
  obj.insert("abbreviation", StorageValue(e->abbreviation));
  obj.insert("code", StorageValue(e->code));
  obj.insert("conversionMultiplier", StorageValue(e->conversionMultiplier));
  obj.insert("conversionOffset", StorageValue(e->conversionOffset));
  obj.insert("quantityKind", StorageValue(e->quantityKind));
  obj.insert("symbol", StorageValue(e->symbol));
  obj.insert("unit", StorageValue(e->unit));		    
  return true;
}

bool UnitStore :: get(Unit *e, StorageObject const &obj)
{
  auto name = obj.find("__name__").toString();
  auto version = obj.find("__version__").toString();
  e->abbreviation = obj.find("abbreviation").toString();
  e->code = obj.find("code").toString();
  e->conversionMultiplier = obj.find("conversionMultiplier").toDouble();
  e->conversionOffset = obj.find("conversionOffset").toDouble();
  e->quantityKind = obj.find("quantityKind").toString();
  e->symbol = obj.find("symbol").toString();
  e->unit = obj.find("unit").toString();
  return true;
}
#+END_SRC

** Run the entity code-generator compile time

The qmake utility can be extended with custom compilers and
generators. To define our new code generator we can define this in the
qmake .pro file.

#+BEGIN_SRC js
# Code Generators
entitygencxx.name     = "entity build"
entitygencxx.output   = ${QMAKE_FILE_BASE}.cpp
entitygencxx.commands = $$PWD/genxx.js ${QMAKE_FILE_BASE} $$ENTITY_CPP_VIEW > ${QMAKE_FILE_OUT}
entitygencxx.input    = ENTITY
entitygencxx.depends  = ${QMAKE_FILE_BASE}.h 
entitygencxx.variable_out = SOURCES
entitygencxx.dependency_type = TYPE_C
 
entitygenhxx.name     = "entity header"
entitygenhxx.output   = ${QMAKE_FILE_BASE}.h
entitygenhxx.commands = $$PWD/genxx.js ${QMAKE_FILE_BASE} $$ENTITY_H_VIEW > ${QMAKE_FILE_OUT}
entitygenhxx.input    = ENTITY
entitygenhxx.depends  = $$ENTITY $$ENTITY_H_VIEW $$ENTITY_CPP_VIEW
entitygenhxx.variable_out = HEADERS
entitygenhxx.dependency_type = TYPE_C

QMAKE_EXTRA_COMPILERS += entitygenhxx entitygencxx
#+END_SRC

Details about how to customize and setup your own
QMAKE_EXTRA_COMPILERS can be found in the Qt manual.

To define /unit/ as part of our sources we can simply define a
.pro-file like this:

#+BEGIN_SRC

TARGET  = cppdemo
INCLUDEPATH = .
DEPENDPATH  = .
CONFIG += c++11 porto

ENTITY += unit.json
SOURCES += main.cpp
#+END_SRC

** Rapid development with data

Whenever we need to change or add a parameter in our model, we can
simply perform this operation in the .json file - and then just use
that parameter in the code without thinking about how it got
there. When we are satisfied with the entity, we can give it a
reasonable name and version number and register with the utility
/register-entity-sh/. Then we will be able to transparently access the
stored state of the running simulation from other applications or
scripts. There are vast number of usages of this. By using the
UDP-module in the next chapter can be one way of triggering
background-processes during simulation.


* Using UDP to communicate and run external processes

The Porto framework is not limited to just storing and retrieving
data. It can also be utilized for controlling the process
workflows. One synchronization mechanism that is supported is [[http://en.wikipedia.org/wiki/User_Datagram_Protocol][User
Datagram Protocol]]. This is a lightweight protocol with no handshaking
and setup. UDP works by emitting datagrams. The datagram can be any
text. In our example code, we want to create two script
applications. One is the client-code that emits a JSON datagram that
contains some info, along with a program w/arguments that it wants the
receiver to run.

The other is the server code. This is a script application that creates
a callback that is called when it receives a datagram. It will then
parse the datagram and execute the application. Note that this method
of calling remote procedure is *not* recommended due to the security
hazard this exposes.

UdpSocket is a build-in utility class, and does not require us to call /require/.
#+BEGIN_SRC js
  __main__ = function (args)
  {
    var udpSocket = new UdpSocket();
    var msg = {
	name: "test",
	version: "1.0",
	program: "ls",
	args: ["-al"]
    };
    udpSocket.writeDatagram(JSON.stringify (msg), "127.0.0.1", 1234);
  }
#+END_SRC

When executed, this script will simply emit the datagram and exit. The
server code is a bit more elaborate and contains some features of
Porto that has not yet been discussed. The server is a script that
should set up an event loop. The event loop makes it possible to
create asynchrounous callbacks that is build in the Qt signal/slot
mechanism, and is a build-in utility class called /EventLoop/.

In addition we also need to use the utility class /Process/ which can
control the execution of an application, with asynchronous callback to
catch output coming from stdout, stderr, along with messages giving
the status of the running application, and a callback for the
termination of the application.


#+BEGIN_SRC js
__main__ = function (args)
{
    /* Create the event loop */
    var event = new EventLoop ();

    var udpSocket = require ('./udpsocket.js');
    var u = udpSocket.create (function (udp) {	
        /* Create a callback for the event 'readyRead' */
	udp.readyRead.connect (function () {

            /* Parse the datagram received and print its contents to the console */
	    var datagram = udp.readDatagram ();
	    var o = JSON.parse(datagram.datagram);
	    print(o.name, o.version, o.program);

            /* Instantiate a new Process and create callbacks for when the process
               starts, have available standard output contents, and termination.
             */ 
	    var proc = new Process();
	    (function (p) {
		p.started.connect (function (){
		    print ("process started");
		});

		p.readyReadStandardOutput.connect (function() {
		    print (p.readAllStandardOutput ());
		});

		p["finished(int)"].connect (function (){
		    print ("process finished");
		    event.quit(); /* Quit the server when the program finishes*/
		});
	    })(proc);

            /* Set up the process with the program and arguments given in the datagram */
	    proc.setProgram(o.program);
	    proc.setArguments(o.args);

            /* Run the application */
	    proc.start();
	});
    });
    
    /* Make the socket listen for activity on port 1234 coming from localhost */
    u.bind ("127.0.0.1", 1234);

    /* Enter the event loop */
    event.exec();
}
#+END_SRC

The module udpsocket.js is just a simple high-level function that
instantiates the UdpSocket and pass it to a function argument.

#+BEGIN_SRC js
exports.create = function(fn) {
    var udp = new UdpSocket();
    fn (udp);

    return udp;
}
#+END_SRC

* Displaying contents in a web browser

Working in a scripting shell environment is sometimes not practical
when it comes to presenting information. Creating or generating HTML
for presenting contents is therefore good options. One could also
consider to build /Porto User Interfaces/ as web services. This
chapter will demonstrate the functionality of the tiny webserver
functionality available in /Porto/, in the build-in utility HttpServer.

#+BEGIN_SRC js
  __main__ = function (args)
  {
    var event = new EventLoop();
    var port  = 8081;
    var httpd = new HttpServer(port);
    httpd.setRootDir("html/");
    httpd.start();
    event.exec();
  }
#+END_SRC

By pointing the browser to http://localhost:8081 we should now be able
to view the contents defined under the given root directory. 

Note however, that is not a production web server, and it is limited
to GET requests of type text/html.

* Final notes

This tutorial/overview was intended to give the reader some hands-on
to get started on working with Porto. There are many more things that
Porto is able to do in terms of features, but the key concepts are the
most important. I wish this document has left the reader with a little
deeper understanding of the data-centric design philosophy, and also
inspiration to contribute and extend the framework to fit other tasks
and activities. After all, software is supposed to make work easier,
more fun, and inspire new ideas.

Also note that Porto is in a *very early stage of development*. Do not
expect everything to be smooth and easy, but please make a note of
annoyances, problems, improvement suggestions, and feel free to make
these requirements for the development iteration.

Thomas Hagelien
Trondheim 2014
